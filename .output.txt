diff --git a/src/engine.py b/src/engine.py
index 1f8e2aa..727ad98 100644
--- a/src/engine.py
+++ b/src/engine.py
@@ -1,404 +1,216 @@
 from PIL import Image, ImageGrab
 from docx import Document
 from docx.shared import Inches
-import os
-import sys
-import datetime
-import threading
-import ctypes
-import tempfile
-import shutil
-import queue
-import time
-import io
-import re
-
-from src.hotkeys import kernel32, user32
-# from src.config import ToonConfig  <-- REMOVED: Config is now passed in directly
-
+import os, threading, ctypes, tempfile, shutil, queue, time, io, re
+from src.hotkeys import kernel32 as k, user32 as u
 class ScreenshotSession:
-    def __init__(self, config_data, callback_queue):
-        self.config = config_data
-        self.gui_queue = callback_queue
-
-        self.base_name_no_ext = ""
-        self.current_filename = ""
-        self.session_count = 0
-        self.max_size_bytes = 0
-        self.image_paths = []
-        self.temp_dir = None
-        self.doc = None
-        self.running = True
-        self.status = "Active"
-        self.unsaved_changes = 0
-
-        self.save_queue = queue.Queue()
-        self.clipboard_queue = queue.Queue()
-        self.worker_thread = None
-        self.clipboard_thread = None
-
-        self.file_locked_warning_shown = False
-        self.last_known_size_str = "0 KB"
-
-        self._initialize()
-        self.session_id = self.current_filename
-
-    def _initialize(self):
-        full_dir = self.config['save_dir']
-        filename_input = self.config['filename']
-
-        if not os.path.exists(full_dir):
-            try:
-                os.makedirs(full_dir)
-            except:
-                pass
-
-        full_path = os.path.join(full_dir, filename_input)
-
-        if self.config['save_mode'] == 'folder':
-            if not os.path.exists(full_path):
-                self.current_filename = full_path
-            else:
-                c = 1
-                while True:
-                    new_path = f"{full_path}_{c}"
-                    if not os.path.exists(new_path):
-                        self.current_filename = new_path
-                        break
-                    c += 1
-            self.base_name_no_ext = os.path.basename(self.current_filename)
-        else:
-            c = 0
-            while True:
-                name = filename_input if c == 0 else f"{filename_input}_{c}"
-                f_path = os.path.join(full_dir, name + ".docx")
-                if not os.path.exists(f_path):
-                    self.current_filename = f_path
-                    self.base_name_no_ext = name
-                    break
-                c += 1
-
-        try:
-            mb = float(self.config['max_size'])
-            self.max_size_bytes = int(mb * 1024 * 1024)
-        except:
-            self.max_size_bytes = 0
-
-        self.temp_dir = tempfile.mkdtemp(prefix="Click_")
-
-        if self.config['save_mode'] == 'folder':
-            if not os.path.exists(self.current_filename): os.makedirs(self.current_filename)
+    def __init__(self, cfg, q):
+        self.cfg, self.q, self.base, self.fn, self.cnt, self.max_sz, self.imgs, self.tmp, self.doc, self.run = cfg, q, "", "", 0, 0, [], None, None, True
+        self.sq, self.cq, self.wt, self.ct, self.warn, self.sz_str = queue.Queue(), queue.Queue(), None, None, False, "0 KB"
+        self._init()
+    def _init(self):
+        d, n = self.cfg['save_dir'], self.cfg['filename']
+        if not os.path.exists(d):
+            try: os.makedirs(d)
+            except: pass
+        fp = os.path.join(d, n)
+        if self.cfg['save_mode'] == 'folder':
+            self.fn = fp if not os.path.exists(fp) else self._uniq(fp)
+            self.base = os.path.basename(self.fn)
+            if not os.path.exists(self.fn): os.makedirs(self.fn)
         else:
+            self.fn, self.base = self._uniq_file(d, n)
             self.doc = Document()
-            try:
-                self.doc.save(self.current_filename)
-            except:
-                pass
-
-        self.start_threads()
-
-    def start_threads(self):
-        if self.worker_thread is None or not self.worker_thread.is_alive():
-            self.worker_thread = threading.Thread(target=self._worker_loop, daemon=True)
-            self.worker_thread.start()
-
-        if self.clipboard_thread is None or not self.clipboard_thread.is_alive():
-            self.clipboard_thread = threading.Thread(target=self._clipboard_loop, daemon=True)
-            self.clipboard_thread.start()
-
-    def stop_worker(self):
-        self.running = False
-        if self.doc and self.unsaved_changes > 0:
-            try:
-                self.doc.save(self.current_filename)
-            except:
-                pass
-
+            try: self.doc.save(self.fn)
+            except: pass
+        try: self.max_sz = int(float(self.cfg['max_size']) * 1048576)
+        except: self.max_sz = 0
+        self.tmp = tempfile.mkdtemp(prefix="Click_")
+        self._start()
+    def _uniq(self, p):
+        c = 1
+        while True:
+            np = f"{p}_{c}"
+            if not os.path.exists(np): return np
+            c += 1
+    def _uniq_file(self, d, n):
+        c = 0
+        while True:
+            nn = n if c == 0 else f"{n}_{c}"
+            fp = os.path.join(d, nn + ".docx")
+            if not os.path.exists(fp): return fp, nn
+            c += 1
+    def _start(self):
+        if not self.wt or not self.wt.is_alive(): self.wt = threading.Thread(target=self._w_loop, daemon=True); self.wt.start()
+        if not self.ct or not self.ct.is_alive(): self.ct = threading.Thread(target=self._c_loop, daemon=True); self.ct.start()
+    def stop(self):
+        self.run = False
+        if self.doc:
+            try: self.doc.save(self.fn)
+            except: pass
     def capture(self):
-        if not self.running: return
-        try:
-            img = ImageGrab.grab(all_screens=True)
-        except:
-            return
-
-        self.session_count += 1
-        window_title = self.get_cleaned_window_title() if self.config['log_title'] else None
-
-        self.gui_queue.put(("NOTIFY", self.session_id, self.session_count, self.last_known_size_str))
-
-        if self.config['auto_copy']:
-            path = os.path.join(self.temp_dir, f"clip_{self.session_count}.jpg")
-            self.clipboard_queue.put((img, path))
-
-        self.save_queue.put((img, self.session_count, window_title))
-
+        if not self.run: return
+        try: img = ImageGrab.grab(all_screens=True)
+        except: return
+        self.cnt += 1
+        wt = self._get_wt() if self.cfg['log_title'] else None
+        self.q.put(("NOTIFY", self.fn, self.cnt, self.sz_str))
+        if self.cfg['auto_copy']: self.cq.put((img, os.path.join(self.tmp, f"clip_{self.cnt}.jpg")))
+        self.sq.put((img, self.cnt, wt))
     def undo(self):
-        if not self.running: return
-        self.save_queue.put(("UNDO", None, None))
-
+        if self.run: self.sq.put(("UNDO", None, None))
     def manual_rotate(self):
-        if self.config['save_mode'] == "folder": return
-        self._rotate_file()
-
-    def _worker_loop(self):
+        if self.cfg['save_mode'] != "folder": self._rot()
+    def _w_loop(self):
         while True:
             try:
-                try:
-                    task = self.save_queue.get(timeout=0.1)
-                except queue.Empty:
-                    if not self.running and self.save_queue.empty(): break
-                    continue
-
-                if task[0] == "UNDO":
-                    self._process_undo()
-                else:
-                    self._process_save(task[0], task[1], task[2])
-                self.save_queue.task_done()
-            except Exception as e:
-                print(f"Worker Err: {e}")
-
-    def _process_save(self, img, count, window_title):
+                t = self.sq.get(timeout=0.1)
+                if t[0] == "UNDO": self._undo()
+                else: self._save(*t)
+                self.sq.task_done()
+            except queue.Empty:
+                if not self.run and self.sq.empty(): break
+            except: pass
+    def _save(self, img, c, wt):
         try:
-            if self.config['save_mode'] == "folder":
-                fname = f"{self.base_name_no_ext}_{count}.jpg"
+            fn = f"{self.base}_{c}.jpg" if self.cfg['save_mode'] == "folder" else f"screen_{c}.jpg"
+            ip = os.path.join(self.tmp, fn)
+            img.save(ip, "JPEG", quality=90)
+            self.imgs.append(ip)
+            if self.cfg['save_mode'] == "folder":
+                shutil.copyfile(ip, os.path.join(self.fn, fn))
+                self.sz_str = self._f_sz(self.fn)
             else:
-                fname = f"screen_{count}.jpg"
-
-            img_path = os.path.join(self.temp_dir, fname)
-            img.save(img_path, "JPEG", quality=90)
-            self.image_paths.append(img_path)
-
-            if self.config['save_mode'] == "folder":
-                target = os.path.join(self.current_filename, fname)
-                shutil.copyfile(img_path, target)
-                self.last_known_size_str = self.get_folder_size_str(self.current_filename)
-            else:
-                if os.path.exists(self.current_filename):
-                    curr = os.path.getsize(self.current_filename)
-                    if self.max_size_bytes > 0 and (curr + os.path.getsize(img_path)) > self.max_size_bytes:
-                        self._rotate_file()
-
-                if not self.doc: self.doc = Document(self.current_filename)
-
-                txt = ""
-                if window_title and self.config['append_num']:
-                    txt = f"{window_title} {count}"
-                elif window_title:
-                    txt = window_title
-                elif self.config['append_num']:
-                    txt = str(count)
-
+                if os.path.exists(self.fn) and self.max_sz > 0 and (os.path.getsize(self.fn) + os.path.getsize(ip)) > self.max_sz: self._rot()
+                if not self.doc: self.doc = Document(self.fn)
+                txt = f"{wt} {c}" if wt and self.cfg['append_num'] else (wt or (str(c) if self.cfg['append_num'] else ""))
                 if txt: self.doc.add_paragraph(txt)
-                self.doc.add_picture(img_path, width=Inches(6))
+                self.doc.add_picture(ip, width=Inches(6))
                 self.doc.add_paragraph("-" * 50)
-
-                # FIX: Save Immediately (Removed the "Wait for 3 screenshots" check)
                 try:
-                    self.doc.save(self.current_filename)
-                    self.last_known_size_str = self.get_formatted_size(self.current_filename)
-                    self.file_locked_warning_shown = False
-                    self.unsaved_changes = 0
+                    self.doc.save(self.fn)
+                    self.sz_str, self.warn = self._sz(self.fn), False
                 except PermissionError:
-                    if not self.file_locked_warning_shown:
-                        self.gui_queue.put(("WARNING", "File Locked", "Close Word to save"))
-                        self.file_locked_warning_shown = True
-                    self.last_known_size_str = "File Locked"
-
-            self.gui_queue.put(("UPDATE_SESSION", self.session_id, self.session_count, self.last_known_size_str))
-        except Exception as e:
-            print(f"Save Err: {e}")
-
-    def _process_undo(self):
-        if self.session_count <= 0: return
+                    if not self.warn: self.q.put(("WARNING", "File Locked", "Close Word")); self.warn = True
+                    self.sz_str = "File Locked"
+            self.q.put(("UPDATE_SESSION", self.fn, self.cnt, self.sz_str))
+        except: pass
+    def _undo(self):
+        if self.cnt <= 0: return
         try:
-            if self.image_paths:
-                p = self.image_paths.pop()
+            if self.imgs:
+                p = self.imgs.pop()
                 if os.path.exists(p): os.remove(p)
-
-            if self.config['save_mode'] == 'folder':
-                f = os.path.join(self.current_filename, f"{self.base_name_no_ext}_{self.session_count}.jpg")
+            if self.cfg['save_mode'] == 'folder':
+                f = os.path.join(self.fn, f"{self.base}_{self.cnt}.jpg")
                 if os.path.exists(f): os.remove(f)
-                self.last_known_size_str = self.get_folder_size_str(self.current_filename)
-            else:
-                if self.doc and len(self.doc.paragraphs) >= 2:
-                    try:
-                        removed = 0
-                        while removed < 3 and self.doc.paragraphs:
-                            p = self.doc.paragraphs[-1]
-                            p._element.getparent().remove(p._element)
-                            removed += 1
-                            if removed == 1 and "-" not in p.text and len(p.text) > 0: break
-
-                        self.doc.save(self.current_filename)
-                        self.last_known_size_str = self.get_formatted_size(self.current_filename)
-                    except:
-                        pass
-
-            self.session_count -= 1
-            self.gui_queue.put(("UNDO", self.session_id, self.session_count, self.last_known_size_str))
-        except:
-            pass
-
-    def cleanup(self, delete_files=False):
-        self.stop_worker()
-        if self.temp_dir and os.path.exists(self.temp_dir):
-            try:
-                shutil.rmtree(self.temp_dir)
-            except:
-                pass
-        if delete_files and self.current_filename and os.path.exists(self.current_filename):
-            try:
-                if self.config['save_mode'] == 'folder':
-                    shutil.rmtree(self.current_filename)
-                else:
-                    os.remove(self.current_filename)
-            except:
-                pass
-
-    def _rotate_file(self):
-        # 1. Force save the current file
+                self.sz_str = self._f_sz(self.fn)
+            elif self.doc and len(self.doc.paragraphs) >= 2:
+                try:
+                    r = 0
+                    while r < 3 and self.doc.paragraphs:
+                        p = self.doc.paragraphs[-1]
+                        p._element.getparent().remove(p._element)
+                        r += 1
+                        if r == 1 and "-" not in p.text and len(p.text) > 0: break
+                    self.doc.save(self.fn)
+                    self.sz_str = self._sz(self.fn)
+                except: pass
+            self.cnt -= 1
+            self.q.put(("UNDO", self.fn, self.cnt, self.sz_str))
+        except: pass
+    def cleanup(self, delete=False):
+        self.stop()
+        if self.tmp and os.path.exists(self.tmp):
+            try: shutil.rmtree(self.tmp)
+            except: pass
+        if delete and self.fn and os.path.exists(self.fn):
+            try: shutil.rmtree(self.fn) if self.cfg['save_mode'] == 'folder' else os.remove(self.fn)
+            except: pass
+    def _rot(self):
         if self.doc:
-            try:
-                self.doc.save(self.current_filename)
-            except:
-                pass
+            try: self.doc.save(self.fn)
+            except: pass
         self.doc = None
-
-        dir_n = os.path.dirname(self.current_filename)
-        base = os.path.basename(self.current_filename).rsplit('.', 1)[0]
-
-        match = re.search(r"^(.*)_Part(\d+)$", base)
-
-        if match:
-            # Increment Part Number
-            root_name = match.group(1)
-            current_num = int(match.group(2))
-            new_name = f"{root_name}_Part{current_num + 1}.docx"
-            self.current_filename = os.path.join(dir_n, new_name)
+        d, b = os.path.dirname(self.fn), os.path.basename(self.fn).rsplit('.', 1)[0]
+        m = re.search(r"^(.*)_Part(\d+)$", b)
+        if m:
+            self.fn = os.path.join(d, f"{m.group(1)}_Part{int(m.group(2)) + 1}.docx")
         else:
-            # Rename base file to Part1
-            root_name = base
             c = 1
             while True:
-                p1_name = f"{root_name}_Part{c}.docx"
-                p1_path = os.path.join(dir_n, p1_name)
-                if not os.path.exists(p1_path):
-                    break
+                p1 = os.path.join(d, f"{b}_Part{c}.docx")
+                if not os.path.exists(p1): break
                 c += 1
-
-            # Safety Check: Only rename if file exists
-            if os.path.exists(self.current_filename):
-                try:
-                    os.rename(self.current_filename, p1_path)
-                except Exception as e:
-                    print(f"Rename failed: {e}")
-
-            new_name = f"{root_name}_Part{c + 1}.docx"
-            self.current_filename = os.path.join(dir_n, new_name)
-
-        # Initialize new file
+            if os.path.exists(self.fn):
+                try: os.rename(self.fn, p1)
+                except: pass
+            self.fn = os.path.join(d, f"{b}_Part{c + 1}.docx")
         self.doc = Document()
-        self.doc.save(self.current_filename)
-        self.unsaved_changes = 0
-        self.last_known_size_str = "0 KB"
-        self.gui_queue.put(("UPDATE_FILENAME", self.current_filename))
-
-    def get_cleaned_window_title(self):
+        self.doc.save(self.fn)
+        self.sz_str = "0 KB"
+        self.q.put(("UPDATE_FILENAME", self.fn))
+    def _get_wt(self):
         try:
-            hwnd = user32.GetForegroundWindow()
-            length = user32.GetWindowTextLengthW(hwnd)
-            buff = ctypes.create_unicode_buffer(length + 1)
-            user32.GetWindowTextW(hwnd, buff, length + 1)
-            full = buff.value
-            return full.replace(" - Google Chrome", "").replace(" - Microsoft Edge", "")
-        except:
-            return "Unknown"
-
-    def get_formatted_size(self, fp):
-        if not os.path.exists(fp): return "0 KB"
-        s = os.path.getsize(fp)
-        return f"{s / 1024:.2f} KB" if s < 1048576 else f"{s / 1048576:.2f} MB"
-
-    def get_folder_size_str(self, fp):
-        t = 0
-        for r, d, f in os.walk(fp):
-            for file in f: t += os.path.getsize(os.path.join(r, file))
-        return f"{t / 1024:.2f} KB" if t < 1048576 else f"{t / 1048576:.2f} MB"
-
-    def _clipboard_loop(self):
+            h = u.GetForegroundWindow()
+            l = u.GetWindowTextLengthW(h)
+            b = ctypes.create_unicode_buffer(l + 1)
+            u.GetWindowTextW(h, b, l + 1)
+            return b.value.replace(" - Google Chrome", "").replace(" - Microsoft Edge", "")
+        except: return "Unknown"
+    def _sz(self, p):
+        if not os.path.exists(p): return "0 KB"
+        s = os.path.getsize(p)
+        return f"{s/1024:.2f} KB" if s < 1048576 else f"{s/1048576:.2f} MB"
+    def _f_sz(self, p):
+        t = sum(os.path.getsize(os.path.join(r, f)) for r, _, fs in os.walk(p) for f in fs)
+        return f"{t/1024:.2f} KB" if t < 1048576 else f"{t/1048576:.2f} MB"
+    def _c_loop(self):
         while True:
             try:
-                try:
-                    img, path = self.clipboard_queue.get(timeout=0.1)
-                except queue.Empty:
-                    if not self.running: break
-                    continue
-
-                img.convert("RGB").save(path, "JPEG")
-                self.copy_dual(img, [path])
-                self.clipboard_queue.task_done()
-            except Exception as e:
-                print(f"Clip Err: {e}")
-
-    def copy_dual(self, img, paths):
-        do_image = self.config.get('copy_image', True)
-        do_files = self.config.get('copy_files', True)
-        if not do_image and not do_files: return
-
+                i, p = self.cq.get(timeout=0.1)
+                i.convert("RGB").save(p, "JPEG")
+                self.cp(i, [p])
+                self.cq.task_done()
+            except queue.Empty:
+                if not self.run: break
+            except: pass
+    def cp(self, img, ps):
+        if not self.cfg.get('copy_image', True) and not self.cfg.get('copy_files', True): return
         try:
-            h_dib = None
-            h_drop = None
-
-            if do_image and img:
-                output = io.BytesIO()
-                img.convert("RGB").save(output, "BMP")
-                data = output.getvalue()[14:]
-                output.close()
-                h_dib = kernel32.GlobalAlloc(GPTR, len(data))
-                if h_dib:
-                    p_dib = kernel32.GlobalLock(h_dib)
-                    ctypes.memmove(p_dib, data, len(data))
-                    kernel32.GlobalUnlock(h_dib)
-
-            if do_files and paths:
-                f_txt = "\0".join([os.path.abspath(p) for p in paths]) + "\0\0"
-                f_dat = f_txt.encode('utf-16le')
-                h_drop = kernel32.GlobalAlloc(GPTR, 20 + len(f_dat))
-                if h_drop:
-                    p_drop = kernel32.GlobalLock(h_drop)
-                    header = b'\x14\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00'
-                    ctypes.memmove(p_drop, header, 20)
-                    ctypes.memmove(p_drop + 20, f_dat, len(f_dat))
-                    kernel32.GlobalUnlock(h_drop)
-
-            success = False
+            hd, hf = None, None
+            if self.cfg.get('copy_image', True) and img:
+                o = io.BytesIO()
+                img.convert("RGB").save(o, "BMP")
+                d = o.getvalue()[14:]
+                o.close()
+                hd = k.GlobalAlloc(0x0042, len(d))
+                if hd: ctypes.memmove(k.GlobalLock(hd), d, len(d)); k.GlobalUnlock(hd)
+            if self.cfg.get('copy_files', True) and ps:
+                ft = "\0".join([os.path.abspath(p) for p in ps]) + "\0\0"
+                fd = ft.encode('utf-16le')
+                hf = k.GlobalAlloc(0x0042, 20 + len(fd))
+                if hf:
+                    l = k.GlobalLock(hf)
+                    ctypes.memmove(l, b'\x14\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00', 20)
+                    ctypes.memmove(l + 20, fd, len(fd))
+                    k.GlobalUnlock(hf)
             for _ in range(20):
-                if user32.OpenClipboard(None):
+                if u.OpenClipboard(None):
                     try:
-                        user32.EmptyClipboard()
-                        if h_dib: user32.SetClipboardData(8, h_dib)
-                        if h_drop: user32.SetClipboardData(15, h_drop)
-                        success = True
-                    finally:
-                        user32.CloseClipboard()
+                        u.EmptyClipboard()
+                        if hd: u.SetClipboardData(8, hd)
+                        if hf: u.SetClipboardData(15, hf)
+                    finally: u.CloseClipboard()
                     break
                 time.sleep(0.1)
-
-            if not success:
-                if h_dib: kernel32.GlobalFree(h_dib)
-                if h_drop: kernel32.GlobalFree(h_drop)
-
-        except:
-            pass
-
+            if hd: k.GlobalFree(hd)
+            if hf: k.GlobalFree(hf)
+        except: pass
     def manual_copy_all(self):
-        if not self.image_paths: return
-        self.copy_dual(None, self.image_paths)
-
+        if self.imgs: self.cp(None, self.imgs)
     def copy_master_file_to_clipboard(self):
         if self.doc:
-            try:
-                self.doc.save(self.current_filename)
-            except:
-                pass
-        self.copy_dual(None, [os.path.abspath(self.current_filename)])
\ No newline at end of file
+            try: self.doc.save(self.fn)
+            except: pass
+        self.cp(None, [os.path.abspath(self.fn)])
\ No newline at end of file
diff --git a/src/hotkeys.py b/src/hotkeys.py
index 8eb405e..3e7fbc0 100644
--- a/src/hotkeys.py
+++ b/src/hotkeys.py
@@ -1,108 +1,29 @@
-import ctypes
+import ctypes, threading
 from ctypes import wintypes
-import threading
-
-# ==========================================
-#        WINDOWS API DEFINITIONS
-# ==========================================
-kernel32 = ctypes.windll.kernel32
-user32 = ctypes.windll.user32
-
-SIZE_T = ctypes.c_size_t
-HGLOBAL = wintypes.HGLOBAL
-LPVOID = ctypes.c_void_p
-BOOL = wintypes.BOOL
-UINT = wintypes.UINT
-HANDLE = wintypes.HANDLE
-HWND = wintypes.HWND
-DWORD = wintypes.DWORD
-
-GMEM_FIXED = 0x0000
-GMEM_ZEROINIT = 0x0040
-GPTR = GMEM_FIXED | GMEM_ZEROINIT
-
-kernel32.GlobalAlloc.argtypes = [UINT, SIZE_T]
-kernel32.GlobalAlloc.restype = HGLOBAL
-kernel32.GlobalLock.argtypes = [HGLOBAL]
-kernel32.GlobalLock.restype = LPVOID
-kernel32.GlobalUnlock.argtypes = [HGLOBAL]
-kernel32.GlobalUnlock.restype = BOOL
-kernel32.GlobalFree.argtypes = [HGLOBAL]
-kernel32.GlobalFree.restype = HGLOBAL
-kernel32.GetCurrentThreadId.restype = DWORD
-
-user32.OpenClipboard.argtypes = [HWND]
-user32.OpenClipboard.restype = BOOL
-user32.EmptyClipboard.argtypes = []
-user32.EmptyClipboard.restype = BOOL
-user32.SetClipboardData.argtypes = [UINT, HANDLE]
-user32.SetClipboardData.restype = HANDLE
-user32.CloseClipboard.argtypes = []
-user32.CloseClipboard.restype = BOOL
-user32.MapVirtualKeyW.argtypes = [UINT, UINT]
-user32.MapVirtualKeyW.restype = UINT
-
-user32.RegisterHotKey.argtypes = [HWND, ctypes.c_int, UINT, UINT]
-user32.RegisterHotKey.restype = BOOL
-user32.UnregisterHotKey.argtypes = [HWND, ctypes.c_int]
-user32.UnregisterHotKey.restype = BOOL
-user32.GetMessageW.argtypes = [ctypes.POINTER(wintypes.MSG), HWND, UINT, UINT]
-user32.GetMessageW.restype = BOOL
-user32.TranslateMessage.argtypes = [ctypes.POINTER(wintypes.MSG)]
-user32.DispatchMessageW.argtypes = [ctypes.POINTER(wintypes.MSG)]
-user32.PostThreadMessageW.argtypes = [DWORD, UINT, wintypes.WPARAM, wintypes.LPARAM]
-user32.PostThreadMessageW.restype = BOOL
-
-MOD_ALT = 0x0001
-MOD_CONTROL = 0x0002
-
-# FIX: Dynamic mapping for Tilde (~) key to support non-US keyboards
-VK_OEM_3 = user32.MapVirtualKeyW(0x29, 1)
-if VK_OEM_3 == 0: VK_OEM_3 = 0xC0  # Fallback to US Standard
-
-WM_HOTKEY = 0x0312
-WM_USER = 0x0400
-WM_STOP_LISTENER = WM_USER + 1
-
-
+kernel32, user32 = ctypes.windll.kernel32, ctypes.windll.user32
 class HotkeyListener:
-    def __init__(self, callback_capture, callback_undo, callback_error):
-        self.callback_capture = callback_capture
-        self.callback_undo = callback_undo
-        self.callback_error = callback_error
-        self.thread = None
-        self.thread_id = None
-        self.running = False
-
+    def __init__(self, cb_cap, cb_undo, cb_err):
+        self.cb_cap, self.cb_undo, self.cb_err, self.t, self.tid, self.run = cb_cap, cb_undo, cb_err, None, None, False
     def start(self):
-        if self.thread is None or not self.thread.is_alive():
-            self.running = True
-            self.thread = threading.Thread(target=self._loop, daemon=True)
-            self.thread.start()
-
+        if not self.t or not self.t.is_alive():
+            self.run = True
+            self.t = threading.Thread(target=self._loop, daemon=True)
+            self.t.start()
     def stop(self):
-        self.running = False
-        if self.thread_id:
-            user32.PostThreadMessageW(self.thread_id, WM_STOP_LISTENER, 0, 0)
-
+        self.run = False
+        if self.tid: user32.PostThreadMessageW(self.tid, 0x0401, 0, 0)
     def _loop(self):
-        self.thread_id = kernel32.GetCurrentThreadId()
-        if not user32.RegisterHotKey(None, 1, 0, VK_OEM_3):
-            if self.callback_error: self.callback_error("Capture (~)")
-        if not user32.RegisterHotKey(None, 2, MOD_CONTROL | MOD_ALT, VK_OEM_3):
-            if self.callback_error: self.callback_error("Undo (Ctrl+Alt+~)")
-
+        self.tid = kernel32.GetCurrentThreadId()
+        vk = user32.MapVirtualKeyW(0x29, 1) or 0xC0
+        if not user32.RegisterHotKey(None, 1, 0, vk) and self.cb_err: self.cb_err("Capture (~)")
+        if not user32.RegisterHotKey(None, 2, 3, vk) and self.cb_err: self.cb_err("Undo (Ctrl+Alt+~)")
         msg = wintypes.MSG()
         while user32.GetMessageW(ctypes.byref(msg), None, 0, 0) != 0:
-            if msg.message == WM_HOTKEY:
-                if msg.wParam == 1:
-                    if self.callback_capture: self.callback_capture()
-                elif msg.wParam == 2:
-                    if self.callback_undo: self.callback_undo()
-            elif msg.message == WM_STOP_LISTENER:
-                break
+            if msg.message == 0x0312:
+                if msg.wParam == 1 and self.cb_cap: self.cb_cap()
+                elif msg.wParam == 2 and self.cb_undo: self.cb_undo()
+            elif msg.message == 0x0401: break
             user32.TranslateMessage(ctypes.byref(msg))
             user32.DispatchMessageW(ctypes.byref(msg))
-
         user32.UnregisterHotKey(None, 1)
         user32.UnregisterHotKey(None, 2)
\ No newline at end of file
diff --git a/src/main.py b/src/main.py
index eadfb8a..05c16be 100644
--- a/src/main.py
+++ b/src/main.py
@@ -1,762 +1,302 @@
 import customtkinter as ctk
 import tkinter as tk
 from tkinter import filedialog, ttk, messagebox
-import os
-import datetime
-import threading
-import ctypes
-import tempfile
-import shutil
-import queue
-import re
-import sys
-
+import os, datetime, threading, tempfile, shutil, queue, re, sys
 from src.utils import resource_path, set_dpi_awareness
 from src.hotkeys import HotkeyListener
 from src.engine import ScreenshotSession
-
-# --- Merged from config.py ---
 class ToonConfig:
     @staticmethod
-    def load(filepath):
-        config = {}
-        if not os.path.exists(filepath): return config
+    def load(fp):
+        c = {}
+        if not os.path.exists(fp): return c
         try:
-            with open(filepath, 'r') as f:
-                for line in f:
-                    if ':' in line:
-                        k, v = line.split(':', 1)
-                        config[k.strip()] = v.strip() == 'True' if v.strip() in ['True', 'False'] else v.strip()
-        except:
-            pass
-        return config
-
+            with open(fp, 'r') as f:
+                for l in f:
+                    if ':' in l:
+                        k, v = l.split(':', 1)
+                        c[k.strip()] = v.strip() == 'True' if v.strip() in ['True', 'False'] else v.strip()
+        except: pass
+        return c
     @staticmethod
-    def save(filepath, data):
+    def save(fp, d):
         try:
-            with open(filepath, 'w') as f:
-                for k, v in data.items(): f.write(f"{k}: {v}\n")
-        except:
-            pass
-
-# --- Merged from ui_components.py ---
+            with open(fp, 'w') as f:
+                for k, v in d.items(): f.write(f"{k}: {v}\n")
+        except: pass
 class AutoScrollFrame(ctk.CTkFrame):
-    def __init__(self, master, bg_color_hex, **kwargs):
-        super().__init__(master, **kwargs)
-        self.grid_rowconfigure(0, weight=1)
-        self.grid_columnconfigure(0, weight=1)
-
-        self.canvas = tk.Canvas(self, highlightthickness=0, bd=0, bg=bg_color_hex)
-        self.canvas.grid(row=0, column=0, sticky="nsew")
-
-        self.vsb = ctk.CTkScrollbar(self, orientation="vertical", command=self.canvas.yview)
-        self.hsb = ctk.CTkScrollbar(self, orientation="horizontal", command=self.canvas.xview)
-        self.canvas.configure(yscrollcommand=self.vsb.set, xscrollcommand=self.hsb.set)
-
-        self.scrollable_frame = ctk.CTkFrame(self.canvas, fg_color=bg_color_hex)
-        self.canvas_window = self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
-
-        self.scrollable_frame.bind("<Configure>", self._on_frame_configure)
-        self.canvas.bind("<Configure>", self._on_canvas_configure)
-
-        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
-        self.canvas.bind_all("<Shift-MouseWheel>", self._on_shift_mousewheel)
-
-    def _on_frame_configure(self, event):
-        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
-        self._toggle_scrollbars()
-
-    def _on_canvas_configure(self, event):
-        if self.scrollable_frame.winfo_reqwidth() < event.width:
-            self.canvas.itemconfig(self.canvas_window, width=event.width)
-        self._toggle_scrollbars()
-
-    def _toggle_scrollbars(self):
-        bbox = self.canvas.bbox("all")
-        if not bbox: return
-        if (bbox[3] - bbox[1]) > self.canvas.winfo_height():
-            self.vsb.grid(row=0, column=1, sticky="ns")
-        else:
-            self.vsb.grid_forget()
-        if (bbox[2] - bbox[0]) > self.canvas.winfo_width():
-            self.hsb.grid(row=1, column=0, sticky="ew")
-        else:
-            self.hsb.grid_forget()
-
-    def _on_mousewheel(self, event):
-        if self.vsb.winfo_ismapped():
-            self.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
-
-    def _on_shift_mousewheel(self, event):
-        if self.hsb.winfo_ismapped():
-            self.canvas.xview_scroll(int(-1 * (event.delta / 120)), "units")
-
-    def update_bg_color(self, color):
-        self.canvas.configure(bg=color)
-        self.scrollable_frame.configure(fg_color=color)
-        self.canvas.update_idletasks()
-
+    def __init__(self, m, bg, **kw):
+        super().__init__(m, **kw)
+        self.grid_rowconfigure(0, weight=1); self.grid_columnconfigure(0, weight=1)
+        self.cv = tk.Canvas(self, highlightthickness=0, bd=0, bg=bg)
+        self.cv.grid(row=0, column=0, sticky="nsew")
+        self.vsb = ctk.CTkScrollbar(self, orientation="vertical", command=self.cv.yview)
+        self.hsb = ctk.CTkScrollbar(self, orientation="horizontal", command=self.cv.xview)
+        self.cv.configure(yscrollcommand=self.vsb.set, xscrollcommand=self.hsb.set)
+        self.sf = ctk.CTkFrame(self.cv, fg_color=bg)
+        self.cw = self.cv.create_window((0, 0), window=self.sf, anchor="nw")
+        self.sf.bind("<Configure>", lambda e: (self.cv.configure(scrollregion=self.cv.bbox("all")), self._sb()))
+        self.cv.bind("<Configure>", lambda e: (self.cv.itemconfig(self.cw, width=e.width) if self.sf.winfo_reqwidth() < e.width else None, self._sb()))
+        self.cv.bind_all("<MouseWheel>", lambda e: self.cv.yview_scroll(int(-1*(e.delta/120)), "units") if self.vsb.winfo_ismapped() else None)
+        self.cv.bind_all("<Shift-MouseWheel>", lambda e: self.cv.xview_scroll(int(-1*(e.delta/120)), "units") if self.hsb.winfo_ismapped() else None)
+    def _sb(self):
+        b = self.cv.bbox("all")
+        if not b: return
+        self.vsb.grid(row=0, column=1, sticky="ns") if (b[3]-b[1]) > self.cv.winfo_height() else self.vsb.grid_forget()
+        self.hsb.grid(row=1, column=0, sticky="ew") if (b[2]-b[0]) > self.cv.winfo_width() else self.hsb.grid_forget()
+    def update_bg_color(self, c):
+        self.cv.configure(bg=c); self.sf.configure(fg_color=c); self.cv.update_idletasks()
 set_dpi_awareness()
-
 class ModernUI(ctk.CTk):
     def __init__(self):
         super().__init__()
-        ctk.set_appearance_mode("Dark")
-        ctk.set_default_color_theme("dark-blue")
-
-        self.handler_queue = queue.Queue()
-        self.instance_sessions = {}
-        self.main_active_key = None
-        self.anchor_dir_backup = None
-        self.notification_timer = None
-        self.settings_file = "config.toon"
-
-        self._cleanup_old_temp()
-
-        self.ui_colors = {
-            "bg_main": ("#F3F3F3", "#181818"),
-            "bg_sidebar": ("#FFFFFF", "#121212"),
-            "card": ("#FFFFFF", "#2b2b2b"),
-            "text": ("black", "white"),
-            "text_sec": ("gray20", "gray80"),
-            "input_bg": ("#E0E0E0", "#383838"),
-            "accent": "#2196F3", "accent_hover": "#1976D2",
-            "success": "#4CAF50", "success_hover": "#388E3C",
-            "danger": "#F44336", "danger_hover": "#D32F2F",
-            "btn_text": ("black", "white"),
-            "btn_default": ("#D0D0D0", "#555555"),
-            "btn_default_hover": ("#B0B0B0", "#666666"),
-            "accent_disabled": ("#AED6F1", "#1F3A52"),
-            "success_disabled": ("#A5D6A7", "#1E4222"),
-            "danger_disabled": ("#EF9A9A", "#4A1F1F"),
-        }
-
-        self.kernel_config = ToonConfig.load(self.settings_file)
-        self.user_window_w = int(self.kernel_config.get("w", 950))
-        self.main_window_h = int(self.kernel_config.get("h", 700))
-        self.app_title_text = "Click!"
-        self.root_geometry = f"{self.user_window_w}x{self.main_window_h}"
-        self.hotkey_manager = None
-        self.running_state = True
-
-        self.geometry(self.root_geometry)
-        self.title(self.app_title_text)
-        self.configure(fg_color=self.ui_colors["bg_main"])
-
-        try:
-            myappid = 'himansu.clicktool.screenshot.v1'
-            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)
-        except Exception:
-            pass
-
-        self.grid_columnconfigure(1, weight=1)
-        self.grid_rowconfigure(0, weight=1)
-
-        self.sidebar = ctk.CTkFrame(self, width=280, corner_radius=0, fg_color=self.ui_colors["bg_sidebar"])
-        self.sidebar.grid(row=0, column=0, sticky="nsew")
-        self.sidebar.grid_rowconfigure(3, weight=1)
-
-        self.logo_label = ctk.CTkLabel(self.sidebar, text="Click!", font=ctk.CTkFont(size=20, weight="bold"),
-                                       text_color=self.ui_colors["text"])
-        self.logo_label.grid(row=0, column=0, padx=20, pady=(20, 10), sticky="w")
-
-        self.switch_theme = ctk.CTkSwitch(self.sidebar, text="Dark Mode", command=self.toggle_theme, onvalue="Dark",
-                                          offvalue="Light", text_color=self.ui_colors["text"])
-        self.switch_theme.grid(row=1, column=0, padx=20, pady=10, sticky="w")
-        self.switch_theme.select()
-
-        ctk.CTkLabel(self.sidebar, text="ACTIVE SESSIONS", font=ctk.CTkFont(size=12, weight="bold"),
-                     text_color=self.ui_colors["text_sec"]).grid(row=2, column=0, padx=20, pady=(20, 5), sticky="w")
-
-        self.tree_frame = ctk.CTkFrame(self.sidebar, fg_color="transparent")
-        self.tree_frame.grid(row=3, column=0, padx=10, pady=5, sticky="nsew")
-
-        self.style = ttk.Style()
-        self.style.theme_use("clam")
-        self.update_tree_style("Dark")
-
-        self.tree = ttk.Treeview(self.tree_frame, columns=("status", "count"), show="tree", selectmode="browse")
-        self.tree.column("#0", width=120)
-        self.tree.column("status", width=60, anchor="center")
-        self.tree.column("count", width=40, anchor="center")
-        self.tree.pack(side="left", fill="both", expand=True)
-        self.tree.bind("<<TreeviewSelect>>", self.on_list_select)
-
-        self.action_frame = ctk.CTkFrame(self.sidebar, fg_color="transparent")
-        self.action_frame.grid(row=4, column=0, padx=15, pady=20, sticky="ew")
-
-        self.btn_resume = ctk.CTkButton(self.action_frame, text="RESUME", command=self.resume_selected,
-                                        fg_color=self.ui_colors["accent_disabled"],
-                                        hover_color=self.ui_colors["accent_hover"],
-                                        text_color=self.ui_colors["btn_text"], state="disabled", height=32)
-        self.btn_resume.pack(fill="x", pady=5)
-
-        self.btn_save = ctk.CTkButton(self.action_frame, text="SAVE & CLOSE", command=self.save_close_selected,
-                                      fg_color=self.ui_colors["success_disabled"],
-                                      hover_color=self.ui_colors["success_hover"],
-                                      text_color=self.ui_colors["btn_text"], state="disabled", height=32)
-        self.btn_save.pack(fill="x", pady=5)
-
-        self.btn_discard = ctk.CTkButton(self.action_frame, text="DISCARD", command=self.discard_selected,
-                                         fg_color=self.ui_colors["danger_disabled"],
-                                         hover_color=self.ui_colors["danger_hover"],
-                                         text_color=self.ui_colors["btn_text"], state="disabled", height=32)
-        self.btn_discard.pack(fill="x", pady=5)
-
-        self.btn_copy_session = ctk.CTkButton(self.action_frame, text="COPY SESSION FILE", command=self.copy_selected_session,
-                                              fg_color=self.ui_colors["btn_default"],
-                                              hover_color=self.ui_colors["btn_default_hover"],
-                                              text_color=self.ui_colors["btn_text"], state="disabled", height=32)
-        self.btn_copy_session.pack(fill="x", pady=5)
-
-        initial_bg = self.ui_colors["bg_main"][1] if ctk.get_appearance_mode() == "Dark" else self.ui_colors["bg_main"][0]
-        self.main_area = AutoScrollFrame(self, bg_color_hex=initial_bg, corner_radius=0)
-        self.main_area.grid(row=0, column=1, sticky="nsew", padx=30, pady=30)
-        self.main_area.grid_columnconfigure(0, weight=1)
-
-        content_parent = self.main_area.scrollable_frame
-
-        ctk.CTkLabel(content_parent, text="Start New Session", font=ctk.CTkFont(size=24, weight="bold"),
-                     text_color=self.ui_colors["text"]).grid(row=0, column=0, sticky="w", pady=(0, 20))
-
-        self.card_config = ctk.CTkFrame(content_parent, fg_color=self.ui_colors["card"], corner_radius=15)
-        self.card_config.grid(row=1, column=0, sticky="ew", pady=(0, 15))
-        self.card_config.grid_columnconfigure(1, weight=1)
-
-        ctk.CTkLabel(self.card_config, text="Name", text_color=self.ui_colors["text_sec"]).grid(row=0, column=0,
-                                                                                                padx=20, pady=15,
-                                                                                                sticky="w")
-        self.entry_name = ctk.CTkEntry(self.card_config, placeholder_text="screenshot", border_width=0,
-                                       fg_color=self.ui_colors["input_bg"], text_color=self.ui_colors["text"])
-        self.entry_name.grid(row=0, column=1, padx=(0, 20), pady=15, sticky="ew")
-
-        ctk.CTkLabel(self.card_config, text="Path", text_color=self.ui_colors["text_sec"]).grid(row=1, column=0,
-                                                                                                padx=20, pady=(0, 15),
-                                                                                                sticky="w")
-        path_frame = ctk.CTkFrame(self.card_config, fg_color="transparent")
-        path_frame.grid(row=1, column=1, padx=(0, 20), pady=(0, 15), sticky="ew")
-        self.entry_dir = ctk.CTkEntry(path_frame, border_width=0, fg_color=self.ui_colors["input_bg"],
-                                      text_color=self.ui_colors["text"])
-        self.entry_dir.pack(side="left", fill="x", expand=True, padx=(0, 10))
-        ctk.CTkButton(path_frame, text="...", width=40, fg_color="#444", hover_color="#555", command=self.browse,
-                      text_color="white").pack(side="right")
-
-        ctk.CTkLabel(self.card_config, text="Mode", text_color=self.ui_colors["text_sec"]).grid(row=2, column=0,
-                                                                                                padx=20, pady=(0, 15),
-                                                                                                sticky="w")
-        self.combo_mode = ctk.CTkComboBox(self.card_config, values=["Word Document", "Folder"], border_width=0,
-                                          button_color="#444", text_color=self.ui_colors["text"],
-                                          fg_color=self.ui_colors["input_bg"])
-        self.combo_mode.grid(row=2, column=1, padx=(0, 20), pady=(0, 15), sticky="ew")
-
-        ctk.CTkLabel(self.card_config, text="Max Size (MB)", text_color=self.ui_colors["text_sec"]).grid(row=3,
-                                                                                                         column=0,
-                                                                                                         padx=20,
-                                                                                                         pady=(0, 15),
-                                                                                                         sticky="w")
-        self.entry_size = ctk.CTkEntry(self.card_config, placeholder_text="0 = Unlimited", border_width=0,
-                                       fg_color=self.ui_colors["input_bg"], text_color=self.ui_colors["text"])
-        self.entry_size.grid(row=3, column=1, padx=(0, 20), pady=(0, 15), sticky="ew")
-        self.entry_size.insert(0, "0")
-
-        self.card_opts = ctk.CTkFrame(content_parent, fg_color=self.ui_colors["card"], corner_radius=15)
-        self.card_opts.grid(row=2, column=0, sticky="ew", pady=(0, 20))
-
-        self.var_title = ctk.BooleanVar()
-        self.var_num = ctk.BooleanVar(value=True)
-        self.var_auto = ctk.BooleanVar()
-        self.var_save_date = ctk.BooleanVar(value=True)
-
-        ctk.CTkCheckBox(self.card_opts, text="Log Window Title", variable=self.var_title,
-                        text_color=self.ui_colors["text"]).grid(row=0, column=0, padx=20, pady=15, sticky="w")
-        ctk.CTkCheckBox(self.card_opts, text="Append Number", variable=self.var_num,
-                        text_color=self.ui_colors["text"]).grid(row=0, column=1, padx=20, pady=15, sticky="w")
-        ctk.CTkCheckBox(self.card_opts, text="Save by Date", variable=self.var_save_date,
-                        command=self._update_path_visual, text_color=self.ui_colors["text"]).grid(row=0, column=2,
-                                                                                                  padx=20, pady=15,
-                                                                                                  sticky="w")
-
-        ctk.CTkCheckBox(self.card_opts, text="Auto-Copy", variable=self.var_auto, command=self._validate_auto,
-                        text_color=self.ui_colors["text"]).grid(row=1, column=0, padx=20, pady=(0, 15), sticky="w")
-
-        div = ctk.CTkFrame(self.card_opts, height=2, fg_color="gray")
-        div.grid(row=2, column=0, columnspan=3, sticky="ew", padx=10)
-
-        ctk.CTkLabel(self.card_opts, text="Clipboard Options:", text_color=self.ui_colors["text_sec"],
-                     font=ctk.CTkFont(size=11)).grid(row=3, column=0, padx=20, pady=10, sticky="w")
-
-        self.var_copy_files = ctk.BooleanVar(value=True)
-        self.var_copy_img = ctk.BooleanVar(value=True)
-        ctk.CTkCheckBox(self.card_opts, text="Files (Explorer)", variable=self.var_copy_files,
-                        command=self._validate_subs, text_color=self.ui_colors["text"]).grid(row=3, column=1, padx=20,
-                                                                                             pady=10, sticky="w")
-        ctk.CTkCheckBox(self.card_opts, text="Image (Bitmap)", variable=self.var_copy_img, command=self._validate_subs,
-                        text_color=self.ui_colors["text"]).grid(row=3, column=2, padx=20, pady=10, sticky="w")
-
-        self.btn_start = ctk.CTkButton(content_parent, text="START SESSION", height=50, corner_radius=25,
-                                       font=ctk.CTkFont(size=16, weight="bold"), command=self.start_session,
-                                       fg_color=self.ui_colors["accent"], text_color="white")
-        self.btn_start.grid(row=4, column=0, sticky="ew", pady=10)
-
-        self.btn_split = ctk.CTkButton(content_parent, text="SPLIT FILE", height=30, width=120,
-                                       command=self.manual_rotate,
-                                       fg_color=self.ui_colors["btn_default"],
-                                       hover_color=self.ui_colors["btn_default_hover"],
-                                       text_color=self.ui_colors["btn_text"], state="disabled")
-        self.btn_split.grid(row=5, column=0, sticky="w", padx=20, pady=(10, 0))
-
-        self.btn_copy = ctk.CTkButton(content_parent, text="COPY ALL", height=30, width=120, command=self.copy_all,
-                                      fg_color=self.ui_colors["btn_default"],
-                                      hover_color=self.ui_colors["btn_default_hover"],
-                                      text_color=self.ui_colors["btn_text"], state="disabled")
-        self.btn_copy.grid(row=5, column=0, sticky="e", padx=20, pady=(10, 0))
-
-        self.lbl_status = ctk.CTkLabel(content_parent, text="Ready to capture", text_color=self.ui_colors["text_sec"])
-        self.lbl_status.grid(row=6, column=0, pady=(20, 0))
-        ctk.CTkLabel(content_parent, text="~ (Capture)    |    Ctrl+Alt+~ (Undo)",
-                     text_color=self.ui_colors["text_sec"],
-                     font=ctk.CTkFont(size=11)).grid(row=7, column=0)
-
-        self.notif = ctk.CTkToplevel(self)
-        self.notif.withdraw()
-        self.notif.overrideredirect(True)
-        self.notif.attributes("-topmost", True)
-        self.notif_frame = ctk.CTkFrame(self.notif, fg_color=self.ui_colors["bg_sidebar"], corner_radius=10,
-                                        border_width=1, border_color="gray")
-        self.notif_frame.pack(fill="both", expand=True)
-        self.notif_label = ctk.CTkLabel(self.notif_frame, text="", font=ctk.CTkFont(size=13, weight="bold"),
-                                        text_color=self.ui_colors["text"])
-        self.notif_label.pack(expand=True, padx=20, pady=10)
-
-        self.load_defaults()
-
-        # --- BRANDING FIX ---
-        # Define the path and apply icon BEFORE starting background threads
-        self.icon_path = resource_path("assets/app_icon.ico")
-        self._apply_branding()
-        # Overrides CustomTkinter's default blue logo after it finishes initializing
-        self.after(200, self._apply_branding)
-
-        # Now start the background logic
-        self.hotkey_manager = HotkeyListener(self.on_hotkey_capture, self.on_hotkey_undo, self.on_hotkey_error)
-        self.hotkey_manager.start()
-        self.check_queue()
-        self.protocol("WM_DELETE_WINDOW", self.on_app_close)
-
-        # --- SPLASH SCREEN LOGIC ---
-        # 1. Handle PyInstaller Splash (if present)
+        ctk.set_appearance_mode("Dark"); ctk.set_default_color_theme("dark-blue")
+        self.q, self.sess, self.act, self.bkp, self.tmr, self.cfg_f = queue.Queue(), {}, None, None, None, "config.toon"
+        self._cln()
+        self.col = {"bg": ("#F3F3F3", "#181818"), "sb": ("#FFFFFF", "#121212"), "cd": ("#FFFFFF", "#2b2b2b"), "tx": ("black", "white"), "tx2": ("gray20", "gray80"), "ib": ("#E0E0E0", "#383838"), "ac": "#2196F3", "ach": "#1976D2", "sc": "#4CAF50", "sch": "#388E3C", "dg": "#F44336", "dgh": "#D32F2F", "bt": ("black", "white"), "bd": ("#D0D0D0", "#555555"), "bdh": ("#B0B0B0", "#666666"), "acd": ("#AED6F1", "#1F3A52"), "scd": ("#A5D6A7", "#1E4222"), "dgd": ("#EF9A9A", "#4A1F1F")}
+        self.k_cfg = ToonConfig.load(self.cfg_f)
+        self.geometry(f"{int(self.k_cfg.get('w', 950))}x{int(self.k_cfg.get('h', 700))}")
+        self.title("Click!"); self.configure(fg_color=self.col["bg"])
+        try: ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID('himansu.clicktool.screenshot.v1')
+        except: pass
+        self.grid_columnconfigure(1, weight=1); self.grid_rowconfigure(0, weight=1)
+        self.ma = AutoScrollFrame(self, self.col["bg"][1] if ctk.get_appearance_mode() == "Dark" else self.col["bg"][0], corner_radius=0)
+        self.ma.grid(row=0, column=1, sticky="nsew", padx=30, pady=30); self.ma.grid_columnconfigure(0, weight=1)
+        self.sb = ctk.CTkFrame(self, width=280, corner_radius=0, fg_color=self.col["sb"])
+        self.sb.grid(row=0, column=0, sticky="nsew"); self.sb.grid_rowconfigure(3, weight=1)
+        ctk.CTkLabel(self.sb, text="Click!", font=ctk.CTkFont(size=20, weight="bold"), text_color=self.col["tx"]).grid(row=0, column=0, padx=20, pady=(20, 10), sticky="w")
+        self.sw = ctk.CTkSwitch(self.sb, text="Dark Mode", command=self.tog, onvalue="Dark", offvalue="Light", text_color=self.col["tx"])
+        self.sw.grid(row=1, column=0, padx=20, pady=10, sticky="w"); self.sw.select()
+        ctk.CTkLabel(self.sb, text="ACTIVE SESSIONS", font=ctk.CTkFont(size=12, weight="bold"), text_color=self.col["tx2"]).grid(row=2, column=0, padx=20, pady=(20, 5), sticky="w")
+        self.tf = ctk.CTkFrame(self.sb, fg_color="transparent"); self.tf.grid(row=3, column=0, padx=10, pady=5, sticky="nsew")
+        self.sty = ttk.Style(); self.sty.theme_use("clam"); self.upd_tree("Dark")
+        self.tr = ttk.Treeview(self.tf, columns=("st", "cnt"), show="tree", selectmode="browse")
+        self.tr.column("#0", width=120); self.tr.column("st", width=60, anchor="center"); self.tr.column("cnt", width=40, anchor="center")
+        self.tr.pack(side="left", fill="both", expand=True); self.tr.bind("<<TreeviewSelect>>", self.on_sel)
+        self.af = ctk.CTkFrame(self.sb, fg_color="transparent"); self.af.grid(row=4, column=0, padx=15, pady=20, sticky="ew")
+        self.b_res = ctk.CTkButton(self.af, text="RESUME", command=self.res, fg_color=self.col["acd"], hover_color=self.col["ach"], text_color=self.col["bt"], state="disabled", height=32); self.b_res.pack(fill="x", pady=5)
+        self.b_sav = ctk.CTkButton(self.af, text="SAVE & CLOSE", command=self.sav, fg_color=self.col["scd"], hover_color=self.col["sch"], text_color=self.col["bt"], state="disabled", height=32); self.b_sav.pack(fill="x", pady=5)
+        self.b_dis = ctk.CTkButton(self.af, text="DISCARD", command=self.dis, fg_color=self.col["dgd"], hover_color=self.col["dgh"], text_color=self.col["bt"], state="disabled", height=32); self.b_dis.pack(fill="x", pady=5)
+        self.b_cpy = ctk.CTkButton(self.af, text="COPY SESSION FILE", command=self.cpy_s, fg_color=self.col["bd"], hover_color=self.col["bdh"], text_color=self.col["bt"], state="disabled", height=32); self.b_cpy.pack(fill="x", pady=5)
+        cp = self.ma.sf
+        ctk.CTkLabel(cp, text="Start New Session", font=ctk.CTkFont(size=24, weight="bold"), text_color=self.col["tx"]).grid(row=0, column=0, sticky="w", pady=(0, 20))
+        cc = ctk.CTkFrame(cp, fg_color=self.col["cd"], corner_radius=15); cc.grid(row=1, column=0, sticky="ew", pady=(0, 15)); cc.grid_columnconfigure(1, weight=1)
+        ctk.CTkLabel(cc, text="Name", text_color=self.col["tx2"]).grid(row=0, column=0, padx=20, pady=15, sticky="w")
+        self.e_nm = ctk.CTkEntry(cc, placeholder_text="screenshot", border_width=0, fg_color=self.col["ib"], text_color=self.col["tx"]); self.e_nm.grid(row=0, column=1, padx=(0, 20), pady=15, sticky="ew")
+        ctk.CTkLabel(cc, text="Path", text_color=self.col["tx2"]).grid(row=1, column=0, padx=20, pady=(0, 15), sticky="w")
+        pf = ctk.CTkFrame(cc, fg_color="transparent"); pf.grid(row=1, column=1, padx=(0, 20), pady=(0, 15), sticky="ew")
+        self.e_dr = ctk.CTkEntry(pf, border_width=0, fg_color=self.col["ib"], text_color=self.col["tx"]); self.e_dr.pack(side="left", fill="x", expand=True, padx=(0, 10))
+        ctk.CTkButton(pf, text="...", width=40, fg_color="#444", hover_color="#555", command=self.brw, text_color="white").pack(side="right")
+        ctk.CTkLabel(cc, text="Mode", text_color=self.col["tx2"]).grid(row=2, column=0, padx=20, pady=(0, 15), sticky="w")
+        self.c_md = ctk.CTkComboBox(cc, values=["Word Document", "Folder"], border_width=0, button_color="#444", text_color=self.col["tx"], fg_color=self.col["ib"]); self.c_md.grid(row=2, column=1, padx=(0, 20), pady=(0, 15), sticky="ew")
+        ctk.CTkLabel(cc, text="Max Size (MB)", text_color=self.col["tx2"]).grid(row=3, column=0, padx=20, pady=(0, 15), sticky="w")
+        self.e_sz = ctk.CTkEntry(cc, placeholder_text="0 = Unlimited", border_width=0, fg_color=self.col["ib"], text_color=self.col["tx"]); self.e_sz.grid(row=3, column=1, padx=(0, 20), pady=(0, 15), sticky="ew"); self.e_sz.insert(0, "0")
+        co = ctk.CTkFrame(cp, fg_color=self.col["cd"], corner_radius=15); co.grid(row=2, column=0, sticky="ew", pady=(0, 20))
+        self.v_ti, self.v_nu, self.v_au, self.v_dt = ctk.BooleanVar(), ctk.BooleanVar(value=True), ctk.BooleanVar(), ctk.BooleanVar(value=True)
+        ctk.CTkCheckBox(co, text="Log Window Title", variable=self.v_ti, text_color=self.col["tx"]).grid(row=0, column=0, padx=20, pady=15, sticky="w")
+        ctk.CTkCheckBox(co, text="Append Number", variable=self.v_nu, text_color=self.col["tx"]).grid(row=0, column=1, padx=20, pady=15, sticky="w")
+        ctk.CTkCheckBox(co, text="Save by Date", variable=self.v_dt, command=self.upd_pv, text_color=self.col["tx"]).grid(row=0, column=2, padx=20, pady=15, sticky="w")
+        ctk.CTkCheckBox(co, text="Auto-Copy", variable=self.v_au, command=self.val_au, text_color=self.col["tx"]).grid(row=1, column=0, padx=20, pady=(0, 15), sticky="w")
+        ctk.CTkFrame(co, height=2, fg_color="gray").grid(row=2, column=0, columnspan=3, sticky="ew", padx=10)
+        ctk.CTkLabel(co, text="Clipboard Options:", text_color=self.col["tx2"], font=ctk.CTkFont(size=11)).grid(row=3, column=0, padx=20, pady=10, sticky="w")
+        self.v_cf, self.v_ci = ctk.BooleanVar(value=True), ctk.BooleanVar(value=True)
+        ctk.CTkCheckBox(co, text="Files (Explorer)", variable=self.v_cf, command=self.val_sb, text_color=self.col["tx"]).grid(row=3, column=1, padx=20, pady=10, sticky="w")
+        ctk.CTkCheckBox(co, text="Image (Bitmap)", variable=self.v_ci, command=self.val_sb, text_color=self.col["tx"]).grid(row=3, column=2, padx=20, pady=10, sticky="w")
+        self.b_st = ctk.CTkButton(cp, text="START SESSION", height=50, corner_radius=25, font=ctk.CTkFont(size=16, weight="bold"), command=self.start, fg_color=self.col["ac"], text_color="white"); self.b_st.grid(row=4, column=0, sticky="ew", pady=10)
+        self.b_spl = ctk.CTkButton(cp, text="SPLIT FILE", height=30, width=120, command=self.rot, fg_color=self.col["bd"], hover_color=self.col["bdh"], text_color=self.col["bt"], state="disabled"); self.b_spl.grid(row=5, column=0, sticky="w", padx=20, pady=(10, 0))
+        self.b_ca = ctk.CTkButton(cp, text="COPY ALL", height=30, width=120, command=self.c_all, fg_color=self.col["bd"], hover_color=self.col["bdh"], text_color=self.col["bt"], state="disabled"); self.b_ca.grid(row=5, column=0, sticky="e", padx=20, pady=(10, 0))
+        self.l_st = ctk.CTkLabel(cp, text="Ready to capture", text_color=self.col["tx2"]); self.l_st.grid(row=6, column=0, pady=(20, 0))
+        ctk.CTkLabel(cp, text="~ (Capture)    |    Ctrl+Alt+~ (Undo)", text_color=self.col["tx2"], font=ctk.CTkFont(size=11)).grid(row=7, column=0)
+        self.nt = ctk.CTkToplevel(self); self.nt.withdraw(); self.nt.overrideredirect(True); self.nt.attributes("-topmost", True)
+        self.nf = ctk.CTkFrame(self.nt, fg_color=self.col["sb"], corner_radius=10, border_width=1, border_color="gray"); self.nf.pack(fill="both", expand=True)
+        self.nl = ctk.CTkLabel(self.nf, text="", font=ctk.CTkFont(size=13, weight="bold"), text_color=self.col["tx"]); self.nl.pack(expand=True, padx=20, pady=10)
+        self.ld_def()
+        self.ip = resource_path("assets/app_icon.ico"); self._br(); self.after(200, self._br)
+        self.hk = HotkeyListener(self.hk_cap, self.hk_und, self.hk_err); self.hk.start()
+        self.chk_q(); self.protocol("WM_DELETE_WINDOW", self.on_cl)
         try:
             import pyi_splash
-            if pyi_splash.is_alive():
-                pyi_splash.close()
-        except ImportError:
-            pass
-
-        # 2. Dev Mode Splash (Tkinter)
-        # Only show if NOT frozen (not built)
-        if not getattr(sys, 'frozen', False):
-             self.show_splash()
-
+            if pyi_splash.is_alive(): pyi_splash.close()
+        except: pass
+        if not getattr(sys, 'frozen', False): self.sh_spl()
     def show_splash(self):
-        splash_path = resource_path("assets/splash.png")
-        if os.path.exists(splash_path):
+        sp = resource_path("assets/splash.png")
+        if os.path.exists(sp):
             try:
-                # Create a Toplevel window for the splash screen
-                splash = ctk.CTkToplevel(self)
-                splash.overrideredirect(True)
-                splash.attributes("-topmost", True)
-
-                # Load the image
+                s = ctk.CTkToplevel(self); s.overrideredirect(True); s.attributes("-topmost", True)
                 from PIL import Image
-                pil_image = Image.open(splash_path)
-
-                # Get image dimensions
-                width, height = pil_image.size
-
-                # Center the splash screen
-                screen_width = self.winfo_screenwidth()
-                screen_height = self.winfo_screenheight()
-                x = (screen_width - width) // 2
-                y = (screen_height - height) // 2
-                splash.geometry(f"{width}x{height}+{x}+{y}")
-
-                # Display the image
-                ctk_image = ctk.CTkImage(light_image=pil_image, dark_image=pil_image, size=(width, height))
-                label = ctk.CTkLabel(splash, image=ctk_image, text="")
-                label.pack()
-
-                # Hide the main window initially
+                pi = Image.open(sp); w, h = pi.size
+                sw, sh = self.winfo_screenwidth(), self.winfo_screenheight()
+                s.geometry(f"{w}x{h}+{(sw-w)//2}+{(sh-h)//2}")
+                ci = ctk.CTkImage(light_image=pi, dark_image=pi, size=(w, h))
+                ctk.CTkLabel(s, image=ci, text="").pack()
                 self.withdraw()
-
-                # Schedule splash screen destruction and main window reveal
-                def end_splash():
-                    splash.destroy()
-                    self.deiconify()
-                    self.lift()
-                    self.focus_force()
-
-                # Use after_idle to ensure the splash is drawn before waiting
-                splash.after(100, lambda: self.after(3000, end_splash))
-            except Exception as e:
-                print(f"Splash screen error: {e}")
-                self.deiconify() # Ensure main window shows if splash fails
-        else:
-             self.deiconify() # Ensure main window shows if splash image missing
-
-    def _apply_branding(self):
-        """ Internal method to force apply the window icon """
-        if os.path.exists(self.icon_path):
-            try:
-                self.wm_iconbitmap(self.icon_path)
-                self.iconbitmap(self.icon_path)
-            except Exception:
-                try:
-                    img = tk.PhotoImage(file=self.icon_path)
-                    self.iconphoto(False, img)
-                except:
-                    pass
-
-    def _cleanup_old_temp(self):
-        # Auto-delete temp folders from previous crashed sessions
-        temp_root = tempfile.gettempdir()
+                s.after(100, lambda: self.after(3000, lambda: (s.destroy(), self.deiconify(), self.lift(), self.focus_force())))
+            except: self.deiconify()
+        else: self.deiconify()
+    def _br(self):
+        if os.path.exists(self.ip):
+            try: self.wm_iconbitmap(self.ip); self.iconbitmap(self.ip)
+            except:
+                try: self.iconphoto(False, tk.PhotoImage(file=self.ip))
+                except: pass
+    def _cln(self):
+        tr = tempfile.gettempdir()
         try:
-            for item in os.listdir(temp_root):
-                if item.startswith("Click_") and os.path.isdir(os.path.join(temp_root, item)):
-                    try:
-                        shutil.rmtree(os.path.join(temp_root, item))
-                    except:
-                        pass
-        except:
-            pass
-
-    def toggle_theme(self):
-        mode = self.switch_theme.get()
-        ctk.set_appearance_mode(mode)
-        self.update_tree_style(mode)
-
-        idx = 1 if mode == "Dark" else 0
-        self.main_area.update_bg_color(self.ui_colors["bg_main"][idx])
-
-    def update_tree_style(self, mode):
-        if mode == "Dark":
-            bg = "#121212"
-            fg = "white"
-            field = "#121212"
-            sel = "#2196F3"
-            head_bg = "#1f1f1f"
-        else:
-            bg = "#FFFFFF"
-            fg = "black"
-            field = "#FFFFFF"
-            sel = "#2196F3"
-            head_bg = "#E0E0E0"
-        self.style.configure("Treeview", background=bg, foreground=fg, fieldbackground=field, borderwidth=0,
-                             rowheight=28)
-        self.style.configure("Treeview.Heading", background=head_bg, foreground=fg, relief="flat",
-                             font=('Segoe UI', 9, 'bold'))
-        self.style.map("Treeview", background=[('selected', sel)], foreground=[('selected', 'white')])
-
-    def _validate_auto(self, *args):
-        if self.var_auto.get():
-            if not self.var_copy_files.get() and not self.var_copy_img.get():
-                self.var_copy_img.set(True)
-
-    def _validate_subs(self, *args):
-        if not self.var_copy_files.get() and not self.var_copy_img.get():
-            if self.var_auto.get():
-                self.var_auto.set(False)
-
-    def _update_path_visual(self):
-        self.start_session(dry_run=True)
-
-    def on_hotkey_error(self, key_name):
-        self.handler_queue.put(("HOTKEY_FAIL", key_name))
-
-    def show_notification(self, title, size):
-        self.notif_label.configure(text=f"{title}\n{size}", text_color=self.ui_colors['success'])
-        self.notif.update_idletasks()
-        w = 180
-        h = 60
-        sw = self.winfo_screenwidth()
-        sh = self.winfo_screenheight()
-        self.notif.geometry(f"{w}x{h}+{sw - w - 20}+{sh - h - 60}")
-        self.notif.deiconify()
-        if self.notification_timer: self.after_cancel(self.notification_timer)
-        self.notification_timer = self.after(1500, self.notif.withdraw)
-
-    def browse(self):
+            for i in os.listdir(tr):
+                if i.startswith("Click_") and os.path.isdir(os.path.join(tr, i)):
+                    try: shutil.rmtree(os.path.join(tr, i))
+                    except: pass
+        except: pass
+    def tog(self):
+        m = self.sw.get(); ctk.set_appearance_mode(m); self.upd_tree(m)
+        self.ma.update_bg_color(self.col["bg"][1 if m == "Dark" else 0])
+    def upd_tree(self, m):
+        bg, fg, f, s, h = ("#121212", "white", "#121212", "#2196F3", "#1f1f1f") if m == "Dark" else ("#FFFFFF", "black", "#FFFFFF", "#2196F3", "#E0E0E0")
+        self.sty.configure("Treeview", background=bg, foreground=fg, fieldbackground=f, borderwidth=0, rowheight=28)
+        self.sty.configure("Treeview.Heading", background=h, foreground=fg, relief="flat", font=('Segoe UI', 9, 'bold'))
+        self.sty.map("Treeview", background=[('selected', s)], foreground=[('selected', 'white')])
+    def val_au(self, *a):
+        if self.v_au.get() and not self.v_cf.get() and not self.v_ci.get(): self.v_ci.set(True)
+    def val_sb(self, *a):
+        if not self.v_cf.get() and not self.v_ci.get(): self.v_au.set(False)
+    def upd_pv(self): self.start(dry=True)
+    def hk_err(self, k): self.q.put(("HOTKEY_FAIL", k))
+    def notif_show(self, t, s):
+        self.nl.configure(text=f"{t}\n{s}", text_color=self.col['sc']); self.nt.update_idletasks()
+        w, h, sw, sh = 180, 60, self.winfo_screenwidth(), self.winfo_screenheight()
+        self.nt.geometry(f"{w}x{h}+{sw-w-20}+{sh-h-60}"); self.nt.deiconify()
+        if self.tmr: self.after_cancel(self.tmr)
+        self.tmr = self.after(1500, self.nt.withdraw)
+    def brw(self):
         d = filedialog.askdirectory()
         if d:
-            self.entry_dir.delete(0, "end")
-            self.entry_dir.insert(0, d)
-            if self.var_save_date.get():
-                self._update_path_visual()
-
-    def load_defaults(self):
-        conf = self.kernel_config
-        dd = os.path.join(os.path.expanduser("~"), "Desktop", "Evidence")
-        self.entry_dir.insert(0, conf.get('save_dir', dd))
-        name = conf.get('filename', 'screenshot')
-        if not name: name = "screenshot"
-        self.entry_name.delete(0, "end")
-        self.entry_name.insert(0, name)
-        if conf.get('max_size'):
-            self.entry_size.delete(0, "end")
-            self.entry_size.insert(0, conf.get('max_size'))
-
-        self.var_save_date.set(conf.get("save_by_date", True) == 'True' or conf.get("save_by_date", True) is True)
-        self.var_title.set(conf.get("log_title", False) == 'True' or conf.get("log_title", False) is True)
-        self.var_num.set(conf.get("append_num", True) == 'True' or conf.get("append_num", True) is True)
-        self.var_auto.set(conf.get("auto_copy", False) == 'True' or conf.get("auto_copy", False) is True)
-        self.var_copy_files.set(conf.get("copy_files", True) == 'True' or conf.get("copy_files", True) is True)
-        self.var_copy_img.set(conf.get("copy_image", True) == 'True' or conf.get("copy_image", True) is True)
-
-        saved_mode = conf.get("save_mode", "docx")
-        if saved_mode == "folder":
-            self.combo_mode.set("Folder")
-        else:
-            self.combo_mode.set("Word Document")
-
-    def save_defaults(self):
-        p = self.entry_dir.get()
-        if self.anchor_dir_backup: p = self.anchor_dir_backup
-        data = {
-            "filename": self.entry_name.get(),
-            "save_dir": p,
-            "w": self.winfo_width(), "h": self.winfo_height(),
-            "max_size": self.entry_size.get(),
-            "save_by_date": self.var_save_date.get(),
-            "save_mode": "folder" if self.combo_mode.get() == "Folder" else "docx",
-            "log_title": self.var_title.get(),
-            "append_num": self.var_num.get(),
-            "auto_copy": self.var_auto.get(),
-            "copy_files": self.var_copy_files.get(),
-            "copy_image": self.var_copy_img.get()
-        }
-        ToonConfig.save(self.settings_file, data)
-
-    def start_session(self, dry_run=False):
-        base_dir_input = self.entry_dir.get().strip()
-        raw_name = self.entry_name.get().strip()
-        if not raw_name: raw_name = "screenshot"
-
-        date_str = datetime.datetime.now().strftime("%d-%m-%Y")
-        final_save_dir = base_dir_input
-        self.anchor_dir_backup = None
-
-        if self.var_save_date.get():
-            match = re.search(r'(\d{2}-\d{2}-\d{4})', base_dir_input)
-            if match:
-                existing_date = match.group(1)
-                if existing_date != date_str:
-                    span = match.span(1)
-                    prefix = base_dir_input[:span[0]]
-                    prefix = prefix.rstrip(os.sep)
-                    final_save_dir = os.path.join(prefix, date_str)
-                    self.anchor_dir_backup = prefix
-                else:
-                    final_save_dir = base_dir_input
-                    self.anchor_dir_backup = os.path.dirname(base_dir_input)
-            else:
-                final_save_dir = os.path.join(base_dir_input, date_str)
-                self.anchor_dir_backup = base_dir_input
-        else:
-            final_save_dir = base_dir_input
-            self.anchor_dir_backup = None
-
-        if dry_run:
-            self.entry_dir.delete(0, "end")
-            self.entry_dir.insert(0, final_save_dir)
-            return
-
-        self.entry_dir.delete(0, "end")
-        self.entry_dir.insert(0, final_save_dir)
-
-        if self.combo_mode.get() == "Folder":
-            self.btn_split.configure(state='disabled')
-        else:
-            self.btn_split.configure(state='normal', text_color=self.ui_colors["btn_text"])
-
-        self.btn_copy.configure(state='normal', text_color=self.ui_colors["btn_text"])
-
-        cfg = {
-            "filename": raw_name, "save_dir": final_save_dir,
-            "save_mode": "folder" if self.combo_mode.get() == "Folder" else "docx",
-            "log_title": self.var_title.get(), "append_num": self.var_num.get(),
-            "auto_copy": self.var_auto.get(), "copy_files": self.var_copy_files.get(),
-            "copy_image": self.var_copy_img.get(),
-            "max_size": self.entry_size.get().strip()
-        }
-
-        sess = ScreenshotSession(cfg, self.handler_queue)
-        if self.main_active_key: self.pause_session(self.main_active_key)
-
-        key = sess.current_filename
-        self.instance_sessions[key] = sess
-        self.main_active_key = key
-
-        self.tree.insert("", "end", iid=key, text=os.path.basename(key), values=("Active", "0"))
-        self.tree.selection_set(key)
-        self.update_ui_state()
-
-    def pause_session(self, key):
-        if key in self.instance_sessions:
-            self.instance_sessions[key].status = "Paused"
-            self.tree.set(key, "status", "Paused")
-
-    def resume_selected(self):
-        sel = self.tree.selection()
-        if not sel: return
-        key = sel[0]
-        if self.main_active_key and self.main_active_key != key: self.pause_session(self.main_active_key)
-        self.main_active_key = key
-        self.instance_sessions[key].status = "Active"
-        self.tree.set(key, "status", "Active")
-        self.update_ui_state()
-
-    def save_close_selected(self):
-        sel = self.tree.selection()
-        if not sel: return
-        self._close_internal(sel[0], delete=False)
-
-    def discard_selected(self):
-        sel = self.tree.selection()
-        if not sel: return
-        self._close_internal(sel[0], delete=True)
-
-    def copy_selected_session(self):
-        sel = self.tree.selection()
-        if not sel: return
-        key = sel[0]
-        if key in self.instance_sessions:
-            sess = self.instance_sessions[key]
-            threading.Thread(target=sess.copy_master_file_to_clipboard, daemon=True).start()
-            self.show_notification("Copied File", "Session File Copied")
-
-    def _close_internal(self, key, delete):
-        sess = self.instance_sessions[key]
-        sess.cleanup(delete_files=delete)
-        self.tree.delete(key)
-        del self.instance_sessions[key]
-        if self.main_active_key == key:
-            self.main_active_key = None
-            self.lbl_status.configure(text="No Active Session", text_color="gray")
-            self.btn_split.configure(state='disabled')
-            self.btn_copy.configure(state='disabled')
-
-        if not self.instance_sessions:
-            self.btn_copy_session.configure(state="disabled")
-            if self.anchor_dir_backup:
-                self.entry_dir.delete(0, "end")
-                self.entry_dir.insert(0, self.anchor_dir_backup)
-                self.anchor_dir_backup = None
-
-    def on_list_select(self, event):
-        sel = self.tree.selection()
-        if not sel:
-            self.btn_resume.configure(state="disabled", fg_color=self.ui_colors["accent_disabled"])
-            self.btn_save.configure(state="disabled", fg_color=self.ui_colors["success_disabled"])
-            self.btn_discard.configure(state="disabled", fg_color=self.ui_colors["danger_disabled"])
-            self.btn_split.configure(state="disabled")
-            self.btn_copy.configure(state="disabled")
-            self.btn_copy_session.configure(state="disabled")
+            self.e_dr.delete(0, "end"); self.e_dr.insert(0, d)
+            if self.v_dt.get(): self.upd_pv()
+    def ld_def(self):
+        c = self.k_cfg
+        self.e_dr.insert(0, c.get('save_dir', os.path.join(os.path.expanduser("~"), "Desktop", "Evidence")))
+        self.e_nm.delete(0, "end"); self.e_nm.insert(0, c.get('filename', 'screenshot'))
+        if c.get('max_size'): self.e_sz.delete(0, "end"); self.e_sz.insert(0, c.get('max_size'))
+        self.v_dt.set(c.get("save_by_date", True)); self.v_ti.set(c.get("log_title", False))
+        self.v_nu.set(c.get("append_num", True)); self.v_au.set(c.get("auto_copy", False))
+        self.v_cf.set(c.get("copy_files", True)); self.v_ci.set(c.get("copy_image", True))
+        self.c_md.set("Folder" if c.get("save_mode", "docx") == "folder" else "Word Document")
+    def sv_def(self):
+        p = self.e_dr.get()
+        if self.bkp: p = self.bkp
+        ToonConfig.save(self.settings_file, {"filename": self.e_nm.get(), "save_dir": p, "w": self.winfo_width(), "h": self.winfo_height(), "max_size": self.e_sz.get(), "save_by_date": self.v_dt.get(), "save_mode": "folder" if self.c_md.get() == "Folder" else "docx", "log_title": self.v_ti.get(), "append_num": self.v_nu.get(), "auto_copy": self.v_au.get(), "copy_files": self.v_cf.get(), "copy_image": self.v_ci.get()})
+    def start(self, dry=False):
+        bd, rn = self.e_dr.get().strip(), self.e_nm.get().strip() or "screenshot"
+        dt = datetime.datetime.now().strftime("%d-%m-%Y")
+        fd, self.bkp = bd, None
+        if self.v_dt.get():
+            m = re.search(r'(\d{2}-\d{2}-\d{4})', bd)
+            if m:
+                if m.group(1) != dt:
+                    p = bd[:m.span(1)[0]].rstrip(os.sep)
+                    fd, self.bkp = os.path.join(p, dt), p
+                else: fd, self.bkp = bd, os.path.dirname(bd)
+            else: fd, self.bkp = os.path.join(bd, dt), bd
+        if dry: self.e_dr.delete(0, "end"); self.e_dr.insert(0, fd); return
+        self.e_dr.delete(0, "end"); self.e_dr.insert(0, fd)
+        st = 'disabled' if self.c_md.get() == "Folder" else 'normal'
+        self.b_spl.configure(state=st, text_color=self.col["btn_text"])
+        self.b_ca.configure(state='normal', text_color=self.col["btn_text"])
+        cfg = {"filename": rn, "save_dir": fd, "save_mode": "folder" if self.c_md.get() == "Folder" else "docx", "log_title": self.v_ti.get(), "append_num": self.v_nu.get(), "auto_copy": self.v_au.get(), "copy_files": self.v_cf.get(), "copy_image": self.v_ci.get(), "max_size": self.e_sz.get().strip()}
+        s = ScreenshotSession(cfg, self.q)
+        if self.act: self.pau(self.act)
+        k = s.current_filename; self.sess[k] = s; self.act = k
+        self.tr.insert("", "end", iid=k, text=os.path.basename(k), values=("Active", "0"))
+        self.tr.selection_set(k); self.upd_ui()
+    def pau(self, k):
+        if k in self.sess: self.sess[k].status = "Paused"; self.tr.set(k, "st", "Paused")
+    def res(self):
+        s = self.tr.selection()
+        if not s: return
+        k = s[0]
+        if self.act and self.act != k: self.pau(self.act)
+        self.act = k; self.sess[k].status = "Active"; self.tr.set(k, "st", "Active"); self.upd_ui()
+    def sav(self):
+        s = self.tr.selection()
+        if s: self._cl(s[0], False)
+    def dis(self):
+        s = self.tr.selection()
+        if s: self._cl(s[0], True)
+    def cpy_s(self):
+        s = self.tr.selection()
+        if s and s[0] in self.sess:
+            threading.Thread(target=self.sess[s[0]].copy_master_file_to_clipboard, daemon=True).start()
+            self.notif_show("Copied File", "Session File Copied")
+    def _cl(self, k, d):
+        self.sess[k].cleanup(delete=d); self.tr.delete(k); del self.sess[k]
+        if self.act == k:
+            self.act = None; self.l_st.configure(text="No Active Session", text_color="gray")
+            self.b_spl.configure(state='disabled'); self.b_ca.configure(state='disabled')
+        if not self.sess:
+            self.b_cpy.configure(state="disabled")
+            if self.bkp: self.e_dr.delete(0, "end"); self.e_dr.insert(0, self.bkp); self.bkp = None
+    def on_sel(self, e):
+        s = self.tr.selection()
+        if not s:
+            for b in [self.b_res, self.b_sav, self.b_dis, self.b_spl, self.b_ca, self.b_cpy]: b.configure(state="disabled")
+            self.b_res.configure(fg_color=self.col["acd"]); self.b_sav.configure(fg_color=self.col["scd"]); self.b_dis.configure(fg_color=self.col["dgd"])
             return
-
-        key = sel[0]
-        sess = self.instance_sessions[key]
-        status = sess.status
-
-        self.btn_save.configure(state="normal", fg_color=self.ui_colors["success"],
-                                text_color=self.ui_colors["btn_text"])
-        self.btn_discard.configure(state="normal", fg_color=self.ui_colors["danger"],
-                                   text_color=self.ui_colors["btn_text"])
-        self.btn_copy_session.configure(state="normal")
-
-        if status == "Paused":
-            self.btn_resume.configure(state="normal", fg_color=self.ui_colors["accent"],
-                                      text_color=self.ui_colors["btn_text"])
-        else:
-            self.btn_resume.configure(state="disabled", fg_color=self.ui_colors["accent_disabled"])
-
-        if sess.config['save_mode'] == "folder":
-            self.btn_split.configure(state='disabled')
-        else:
-            self.btn_split.configure(state='normal', text_color=self.ui_colors["btn_text"])
-
-        self.btn_copy.configure(state='normal', text_color=self.ui_colors["btn_text"])
-
-    def update_ui_state(self):
-        if self.main_active_key:
-            name = os.path.basename(self.main_active_key)
-            self.lbl_status.configure(text=f"ACTIVE: {name}", text_color=self.ui_colors["accent"])
-
-    def on_hotkey_capture(self):
-        if self.main_active_key: self.instance_sessions[self.main_active_key].capture()
-
-    def on_hotkey_undo(self):
-        if self.main_active_key: self.instance_sessions[self.main_active_key].undo()
-
-    def manual_rotate(self):
-        if not self.main_active_key: return
-        self.instance_sessions[self.main_active_key].manual_rotate()
-
-    def copy_all(self):
-        if not self.main_active_key: return
-        sess = self.instance_sessions[self.main_active_key]
-        if sess.image_paths:
-            threading.Thread(target=sess.manual_copy_all, daemon=True).start()
-            self.show_notification("Copied All", f"{len(sess.image_paths)} Images")
-
-    def check_queue(self):
+        k = s[0]; st = self.sess[k].status
+        self.b_sav.configure(state="normal", fg_color=self.col["sc"], text_color=self.col["bt"])
+        self.b_dis.configure(state="normal", fg_color=self.col["dg"], text_color=self.col["bt"])
+        self.b_cpy.configure(state="normal")
+        if st == "Paused": self.b_res.configure(state="normal", fg_color=self.col["ac"], text_color=self.col["bt"])
+        else: self.b_res.configure(state="disabled", fg_color=self.col["acd"])
+        st = 'disabled' if self.sess[k].config['save_mode'] == "folder" else 'normal'
+        self.b_spl.configure(state=st, text_color=self.col["bt"])
+        self.b_ca.configure(state='normal', text_color=self.col["bt"])
+    def upd_ui(self):
+        if self.act: self.l_st.configure(text=f"ACTIVE: {os.path.basename(self.act)}", text_color=self.col["ac"])
+    def hk_cap(self):
+        if self.act: self.sess[self.act].capture()
+    def hk_und(self):
+        if self.act: self.sess[self.act].undo()
+    def rot(self):
+        if self.act: self.sess[self.act].manual_rotate()
+    def c_all(self):
+        if self.act and self.sess[self.act].image_paths:
+            threading.Thread(target=self.sess[self.act].manual_copy_all, daemon=True).start()
+            self.notif_show("Copied All", f"{len(self.sess[self.act].image_paths)} Images")
+    def chk_q(self):
         try:
             while True:
-                msg = self.handler_queue.get_nowait()
-                action = msg[0]
-                if action == "NOTIFY":
-                    key, count, size = msg[1], msg[2], msg[3]
-                    if key in self.instance_sessions:
-                        self.tree.set(key, "count", count)
-                        if key == self.main_active_key:
-                            self.lbl_status.configure(text=f"Captured #{count} ({size})",
-                                                      text_color=self.ui_colors["success"])
-                            # FIX: Notification Text Updated
-                            self.show_notification(f"Screenshot #{count}", size)
-                elif action == "UPDATE_SESSION":
-                    key, count, size = msg[1], msg[2], msg[3]
-                    if key in self.instance_sessions:
-                        self.tree.set(key, "count", count)
-                        if key == self.main_active_key:
-                            self.lbl_status.configure(text=f"Saved #{count} ({size})",
-                                                      text_color=self.ui_colors["success"])
-                            # FIX: Notification Text Updated
-                            self.show_notification(f"Screenshot #{count}", size)
-                elif action == "UNDO":
-                    key, count, size = msg[1], msg[2], msg[3]
-                    if key in self.instance_sessions:
-                        self.tree.set(key, "count", count)
-                        if key == self.main_active_key:
-                            self.lbl_status.configure(text=f"Undone (#{count})", text_color="orange")
-                            self.show_notification(f"Undone #{count}", size)
-                elif action == "WARNING":
-                    messagebox.showwarning(msg[1], msg[2])
-                elif action == "HOTKEY_FAIL":
-                    messagebox.showerror("Hotkey Error",
-                                         f"Could not register: {msg[1]}\nClose other apps using this key.")
-                elif action == "UPDATE_FILENAME":
-                    pass
-        except queue.Empty:
-            pass
-        self.after(50, self.check_queue)
-
-    def on_app_close(self):
-        if self.instance_sessions:
+                m = self.q.get_nowait()
+                a = m[0]
+                if a == "NOTIFY":
+                    if m[1] in self.sess:
+                        self.tr.set(m[1], "cnt", m[2])
+                        if m[1] == self.act:
+                            self.l_st.configure(text=f"Captured #{m[2]} ({m[3]})", text_color=self.col["sc"])
+                            self.notif_show(f"Screenshot #{m[2]}", m[3])
+                elif a == "UPDATE_SESSION":
+                    if m[1] in self.sess:
+                        self.tr.set(m[1], "cnt", m[2])
+                        if m[1] == self.act:
+                            self.l_st.configure(text=f"Saved #{m[2]} ({m[3]})", text_color=self.col["sc"])
+                            self.notif_show(f"Screenshot #{m[2]}", m[3])
+                elif a == "UNDO":
+                    if m[1] in self.sess:
+                        self.tr.set(m[1], "cnt", m[2])
+                        if m[1] == self.act:
+                            self.l_st.configure(text=f"Undone (#{m[2]})", text_color="orange")
+                            self.notif_show(f"Undone #{m[2]}", m[3])
+                elif a == "WARNING": messagebox.showwarning(m[1], m[2])
+                elif a == "HOTKEY_FAIL": messagebox.showerror("Hotkey Error", f"Could not register: {m[1]}\nClose other apps using this key.")
+        except queue.Empty: pass
+        self.after(50, self.chk_q)
+    def on_cl(self):
+        if self.sess:
             if not messagebox.askokcancel("Quit", "Open sessions will be saved. Quit?"): return
-        self.save_defaults()
-        if self.hotkey_manager: self.hotkey_manager.stop()
-        for k, s in self.instance_sessions.items(): s.cleanup()
+        self.sv_def()
+        if self.hk: self.hk.stop()
+        for s in self.sess.values(): s.cleanup()
         self.destroy()
-
-
 if __name__ == "__main__":
     app = ModernUI()
     app.mainloop()
\ No newline at end of file
diff --git a/src/utils.py b/src/utils.py
index 45d65f0..22a12ed 100644
--- a/src/utils.py
+++ b/src/utils.py
@@ -1,34 +1,11 @@
-import os
-import sys
-import ctypes
-
+import os, sys, ctypes
 def resource_path(relative_path):
-    """ Get absolute path to resource, works for dev and PyInstaller """
-    if hasattr(sys, '_MEIPASS'):
-        # PyInstaller: Data files are extracted to sys._MEIPASS
-        base_path = sys._MEIPASS
-    else:
-        # Dev mode: src/utils.py is in src/
-        base_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
-
-    # Try with 'src' prefix (common in dev or if structure preserved)
-    full_path = os.path.join(base_path, "src", relative_path)
-    if os.path.exists(full_path):
-        return full_path
-
-    # Try without 'src' prefix (common in frozen builds if flattened)
-    full_path = os.path.join(base_path, relative_path)
-    if os.path.exists(full_path):
-        return full_path
-
-    # Fallback: Check relative to CWD (rarely needed but safe)
+    base = getattr(sys, '_MEIPASS', os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
+    for p in [os.path.join(base, "src", relative_path), os.path.join(base, relative_path)]:
+        if os.path.exists(p): return p
     return os.path.abspath(relative_path)
-
 def set_dpi_awareness():
-    try:
-        ctypes.windll.shcore.SetProcessDpiAwareness(2)
-    except Exception:
-        try:
-            ctypes.windll.user32.SetProcessDPIAware()
-        except Exception:
-            pass
\ No newline at end of file
+    try: ctypes.windll.shcore.SetProcessDpiAwareness(2)
+    except:
+        try: ctypes.windll.user32.SetProcessDPIAware()
+        except: pass
\ No newline at end of file